<!DOCTYPE html>
<html>
    
    <head>
        <meta charset="utf-8" />
        <title>
            JavaScript 变量作用域、this、闭包 - Dogs Blog
        </title>
        <link rel="shortcut icon" href="../dist/favicon.ico">
        <link rel="stylesheet" href="../dist/post.style.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css">
        <link rel="stylesheet" href="http://cdn.bootcss.com/highlight.js/9.2.0/styles/github-gist.min.css">
    </head>
    
    <body>
        <div class="header">
            <button class="label reverse"><a href="../#/category/all">返回列表</a></button>
        </div>

<div class="post-header">
    分类: JavaScript | 发布日期: 2016-05-11
</div>
<div class="divider"></div>
<div class="markdown-body">
    <h1 id="javascript-变量作用域、this、闭包">JavaScript 变量作用域、this、闭包</h1><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F-scope-%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE-scope-chain">变量作用域 scope 和作用域链 scope chain</a><ul>
<li><a href="#var-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">var 变量的作用域和变量提升</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">作用域链</a></li>
<li><a href="#es6-%E4%B8%AD%E7%9A%84-let-%E5%92%8C-const">ES6 中的 let 和 const</a></li>
</ul>
</li>
<li><a href="#this">this</a><ul>
<li><a href="#%E5%85%A8%E5%B1%80%E4%B8%8A%E4%B8%8B%E6%96%87-global-context">全局上下文 global context</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%B8%8A%E4%B8%8B%E6%96%87-function-context">函数上下文 function context</a></li>
<li><a href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E3%80%81%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-this">补充：箭头函数、严格模式下的 this</a></li>
</ul>
</li>
<li><a href="#%E9%97%AD%E5%8C%85-closure">闭包 closure</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="变量作用域-scope-和作用域链-scope-chain">变量作用域 scope 和作用域链 scope chain</h2><blockquote>
<p>JavaScript has two scopes: global and local.<br>A variable that is declared outside a function definition is a global variable, and its value is accessible and modifiable throughout your program.<br>A variable that is declared inside a function definition is local.<br>It is created and destroyed every time the function is executed, and it cannot be accessed by any code outside the function.<br>JavaScript does not support block scope (in which a set of braces {. . .} defines a new scope), except in the special case of block-scoped variables. </p>
</blockquote>
<h3 id="var-变量的作用域和变量提升">var 变量的作用域和变量提升</h3><blockquote>
<p>JavaScript 有两种作用域：全局和局部。<br>在函数定义之外声明的变量是全局变量，它的值可在整个程序中访问和修改。<br>在函数定义内声明的变量是局部变量。每当执行函数时，都会创建和销毁该变量，且无法通过函数之外的任何代码访问该变量。</p>
</blockquote>
<p>JavaScript 中，在函数体内 var 声明的变量是函数级作用域，是局部变量，在本函数体内可以访问，而且是在函数体内任意位置可以访问。</p>
<pre><code>// JS 代码
function test() {
    console.log(val);
    var val = &#39;this is val&#39;;
    console.log(val);

    func();
    function func() {
        for (var i = 0; i &lt; 5; i++) {
        }
        console.log(&#39;i: &#39;, i);
        console.log(&#39;this is func&#39;);
    }
}

test();
</code></pre><p>上述代码结果是：</p>
<pre><code>undefined
this is val
i:  5
this is func
</code></pre><p>JavaScript 解析器预解析代码的时候， <code>test</code> 函数作如下解析：</p>
<pre><code>function test() {
    // 变量提升, 缺省值是 undefined
    var val;

    // 函数声明提升
    function func() {
        // 变量提升
        var i;

        for (i = 0, i &lt; 5, i++) {
        }
        console.log(&#39;i: &#39;, i);
        console.log(&#39;this is func&#39;);
    }

    console.log(val);
    // 变量赋值
    val = &#39;this is val&#39;;
    console.log(val);

    func();
}
</code></pre><p>所以第一次 <code>console.log(val)</code> 时候并不会抛异常， 因为此时变量 <code>val</code> 是被声明过的，值是 <code>undefined</code>。<br>理解 变量提升 ，写代码时应注意 变量污染 的坑。</p>
<blockquote>
<p>如果声明变量时不加 var 直接 <code>val = 1;</code>， 那么 val 是全局变量。</p>
</blockquote>
<h3 id="作用域链">作用域链</h3><p>作用域链包含了执行环境有权访问的所有变量和访问顺序。</p>
<p>作为单线程语言的 JavaScript，初始化代码时会创建一个全局上下文，每一次函数调用都会创建一个执行上下文，执行上下文及包含关系：</p>
<ul>
<li>变量对象<ul>
<li>变量</li>
<li>函数声明</li>
<li>参数(arguments)</li>
</ul>
</li>
<li>作用域链<ul>
<li>有权访问的变量和访问顺序（本作用域变量和所有父作用域变量）。即函数内部属性 <code>scope</code> : 本函数有权访问的[变量、对象、函数]的集合</li>
</ul>
</li>
<li>this 值</li>
</ul>
<p>如下代码：</p>
<pre><code>function func_1() {
    var val_1 = 1;
    // 抛异常： ReferenceError: val_2 is not defined
    console.log(val_1, val_2);

    function func_2() {
        var val_2 = 2;
        // 输出：1 2                                     
        console.log(val_1, val_2);
    }

    func_2();
}

func_1();
</code></pre><p>简言之， func_1 不能访问 func_2 中声明的变量， func_2 可以访问 func_1 中声明的变量。</p>
<p>当在作用域内访问一个变量 <code>x</code> 时，JavaScript 的查找顺序是这样的：</p>
<ol>
<li>当前作用域 <code>var x</code> 的定义 =&gt; 2. <code>x</code> 形参 =&gt; 3. 函数自身名称是否是 <code>x</code> =&gt; 4. 上级作用域从 1 开始查找</li>
</ol>
<h3 id="es6-中的-let-和-const">ES6 中的 let 和 const</h3><blockquote>
<p>ES6 的 let 和 const 实现了块级所用域的变量声明方式，使用 let 和 const 声明变量能有效避免由于变量提升导致的变量污染的问题。</p>
</blockquote>
<p>用 let 和 const 声明的变量作用域是代码块，这个设计比较符合大多数人的思维方式。（代码块简单来说就是 <code>{}</code> 大括号包着的区域）</p>
<pre><code>function test() {
    if (true) {
        var a = &#39;a&#39;;
        let b = &#39;b&#39;;
    }

    // 输出： a
    console.log(a);
    // 抛异常：ReferenceError: b is not defined
    console.log(b);
}

test();
</code></pre><p>关于 const 的作用有必要正确理解：<br>严格来说， const 声明了一个指向变量的指针，并不是说 const 声明的变量不可改变， 而是该指针指向的地址不可改变。</p>
<p>MDN 的例子很赞，这里直接拷过来看：</p>
<pre><code>// NOTE: Constants can be declared with uppercase or lowercase, but a common
// convention is to use all-uppercase letters.

// define MY_FAV as a constant and give it the value 7
const MY_FAV = 7;

// this will fail silently in Firefox and Chrome (but does not fail in Safari)
MY_FAV = 20;

// will print 7
console.log(&quot;my favorite number is: &quot; + MY_FAV);

// trying to redeclare a constant throws an error 
const MY_FAV = 20;

// the name MY_FAV is reserved for constant above, so this will also fail
var MY_FAV = 20; 

// MY_FAV is still 7
console.log(&quot;my favorite number is &quot; + MY_FAV);

// Assigning to A const variable is a syntax error
const A = 1; A = 2;

// const requires an initializer
const FOO; // SyntaxError: missing = in const declaration

// const also works on objects
const MY_OBJECT = {&quot;key&quot;: &quot;value&quot;};

// Overwriting the object fails as above (in Firefox and Chrome but not in Safari)
MY_OBJECT = {&quot;OTHER_KEY&quot;: &quot;value&quot;};

// However, object keys are not protected,
// so the following statement is executed without problems
MY_OBJECT.key = &quot;otherValue&quot;; // Use Object.freeze() to make object immutable
</code></pre><h2 id="this">this</h2><blockquote>
<p>In most cases, the value of this is determined by how a function is called.<br>It can&#39;t be set by assignment during execution, and it may be different each time the function is called. </p>
</blockquote>
<p>简言之： this 总是指向调用该函数的对象。</p>
<h3 id="全局上下文-global-context">全局上下文 global context</h3><pre><code>// 在浏览器中
console.log(this === window); // true
</code></pre><h3 id="函数上下文-function-context">函数上下文 function context</h3><p>在函数中访问 this 时， this 指向调用该函数的对象。</p>
<p>1）全局对象</p>
<pre><code>// 全局变量
val = 1;

function test() {
    console.log(this.val);
}

test(); // 1
</code></pre><p>上例中，调用 test 函数的对象并不是一个自己声明的函数或对象，此时 this 默认值为全局对象。</p>
<p>2) 调用对象</p>
<pre><code>var testObj = {
    val: 1,
    getVal: function() {
        var val = 2;
        return this.val;
    }
};

console.log(testObj.getVal()); // 1
</code></pre><p>上述代码运行输出 <code>1</code>, 顺藤摸瓜，<code>getVal()</code> 函数的调用者是 <code>testObj</code> 对象， 按照 <code>this 指向调用该函数的对象</code> 的原则， <code>getVal()</code> 中的 this 指向 <code>testObj</code> 对象, <code>testObj</code> 对象的 <code>val</code> 值是 1.</p>
<p>3) 构造函数</p>
<pre><code>&#39;use strict&#39;;

function testFunc(val) {
    this.a = val;
    this.b = &#39;bb&#39;;
}

var testInstance = new testFunc(&#39;aa&#39;);

console.log(testInstance.a); // aa
console.log(testInstance.b); // bb
</code></pre><p>当一个函数的调用者是构造函数（new 出来的对象）， this 指向新构造出来的对象 <code>testInstance</code></p>
<p>4) call and apply<br>通过 call apply 将 this 指向特定对象：</p>
<pre><code>function testFunc(val) {
    this.a = val;
    this.b = &#39;bb&#39;;
}

function execFunc() {
    var a = &#39;exec aa&#39;;
    var b = &#39;exec bb&#39;;

    console.log(this.a, this.b);
}

var testInstance = new testFunc(&#39;aa&#39;);

execFunc.call(testInstance); // aa bb
execFunc.apply(testInstance); // aa bb
</code></pre><p>通过 call apply 函数将 execFunc 的 this 值指向 testInstance 对象的 this 值。</p>
<blockquote>
<p>注意: 以 <code>fun.apply() // or call</code> 为例 call apply 的第一个参数是 <code>func 函数运行时的 this 值</code> （第一个参数的解释版本真的多）。<br>二者的区别这里不说。</p>
</blockquote>
<h3 id="补充：箭头函数、严格模式下的-this">补充：箭头函数、严格模式下的 this</h3><p>1) ES6 中的箭头函数 arrow function</p>
<blockquote>
<p>An arrow function expression has a shorter syntax compared to function expressions and lexically binds the this value<br>(does not bind its own this, arguments, super, or new.target).<br>Arrow functions are always anonymous.</p>
</blockquote>
<pre><code>GLOBAL.a = &#39;global aa&#39;;

var testObj = {
    a: &#39;aa&#39;,
    getValArrowFuc: function() {
        var val = (() =&gt; this.a);
        return val();
    },                                 
    getVal: function() {
        var self = this;
        var val = function() {
            return self.a;
        };
        return val();
    },
    getValGlobal: function() {
        var val = function() {
            return this.a;
        };
        return val();
    }
};

console.log(testObj.getValArrowFuc()); // aa
console.log(testObj.getVal()); // aa
console.log(testObj.getValGlobal()); // global aa
</code></pre><p>箭头函数中的 this 值，就是词法作用域的 this 值。</p>
<p>2) 严格模式下的 this</p>
<blockquote>
<p>对于一个开启严格模式的函数，指定的 this 不再被封装为对象，而且如果没有指定 this 的话它值是 undefined.</p>
</blockquote>
<pre><code>&#39;use strict&#39;;
/**
 * from MDN
 */
function fun() { return this; }                

console.log(fun() === undefined); // true
console.log(fun.call(2) === 2); // true
console.log(fun.apply(null) === null); // true
console.log(fun.call(undefined) === undefined); // true
console.log(fun.bind(true)() === true); // true
</code></pre><p>注： 以上所有不考虑 <code>Eval</code></p>
<h2 id="闭包-closure">闭包 closure</h2><blockquote>
<p>Closures are functions whose inner functions refer to independent (free) variables.<br>In other words, the functions defined in the closure &#39;remember&#39; the environment in which they were created.</p>
</blockquote>
<p>闭包的构成：</p>
<ul>
<li>函数</li>
<li>创建该函数的环境，环境由闭包创建时在作用域中的任何局部变量组成</li>
</ul>
<p>自执行函数表达式写法:</p>
<pre><code>var test = (function() {
    var val = 0;

    var add = function(num) {
        val += num;
        return val;
    };
    return add;
})();


console.log(test(3)); // 3
console.log(test(4)); // 7
</code></pre><p>个人感觉这个写法可读性更好：</p>
<pre><code>var test = function() {
    var val = 0;

    var add = function(num) {
        val += num;
        return val;
    };
    return add;
};

/**
 * 此处 instance 是一个闭包。
 * 由 add 函数， 和创建 add 函数时的环境(变量 val)组成
 */
var instance = test();

console.log(instance(3)); // 3
console.log(instance(4)); // 7
</code></pre><p>以下代码：</p>
<pre><code>function test() {
    for (var i = 0; i &lt; 5; i++) {
        setTimeout(() =&gt; {
            console.log(i);
        }, 10);
    }
}

test();
</code></pre><p>输出是：</p>
<pre><code>5
5
5
5
5
</code></pre><p>这里变量 i 的作用域是 test 函数作用域，也就是说 <code>console.log(i)</code> 中的 i 是 test 函数作用域下的同一个变量。</p>
<p>setTimeout 中的函数被执行时，for 遍历已完成并且 i 被赋值为 5.</p>
<p>利用闭包：</p>
<pre><code>function test() {
    for (var i = 0; i &lt; 5; i++) {
        (function (val) {
            setTimeout(() =&gt; {
                console.log(val);     
            }, 10);
        })(i);
    }
}

test();
</code></pre><p>则会输出：</p>
<pre><code>0
1
2
3
4
</code></pre><p>这里我们将 i 赋值成一个局部变量，可在闭包内访问（每次循环创建一个闭包， i 作为该闭包作用域下的局部变量，不跟随外层 i 的值改变）。</p>
<p>闭包对性能有负面影响(尤其是内存占用)，如果不需要使用，则不使用。</p>

</div>
<div class="divider"></div>
<div class="footer">
    作者/版权: <a href="mailto:dongsoso@hotmail.com?subject=Dogs%20Blog%20Email">Dogs</a> | 纠错/贡献: <a href="https://github.com/Dongss/dogs/tree/master/posts/javascript/3.md">Contribute</a>
</div>
    </body>
    <script src="http://cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script src="../dist/post.build.js"></script>
    <script type="text/javascript">
        hljs.initHighlightingOnLoad();
    </script>
</html>

